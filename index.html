<!doctype html>
<html>
<head>
    <title>Leaflet Voltage Contour</title>
    <meta charset="utf-8">
    <link rel="shortcut icon" type="image/ico"
          href="https://raw.githubusercontent.com/posoco/LeafletCanvas/assets/favicon.ico"/>
    <style>
        #map {
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: #333;
        }
    </style>

</head>
<body>
<div id="map"></div>
<link rel="stylesheet" href="libs/leaflet.css"/>
<style>
    .leaflet-div-icon {
        border-radius: 50%;
        behavior: url(PIE.htc); /* remove if you don't care about IE8 */
        background: rgba(0, 0, 0, 0);
        border: 1px solid #aaa;
    }
</style>
<script src="libs/leaflet.js"></script>
<script src="libs/L.CanvasOverlay.js"></script>
<script src="border-geos/wr-geo.js" charset="utf-8"></script>
<script src="sources.js" charset="utf-8"></script>
<script src="libs/rgbhsv.js" charset="utf-8"></script>

<script>
    // All the geoJSONs are copied from http://www.partners-popdev.org/wp-content/themes/original-child/vendor/Geojson/
    //var sources = [[21.6, 71.21, 1.05, "WRLDCMP.SCADA1.A0048293", 400, "AMRELI 400kV SUBSTATION, Gujrat, SUBSTN.AMRL_JTG.BUS.4B1.MES1.KVRY", "OK"]];
    var leafletMap = L.map('map').setView([20.725290873994197, 78.629150390625], 6);
    L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/{z}/{x}/{y}.png")
            .addTo(leafletMap);

    //L.geoJson(statesData).addTo(leafletMap);

    var borderCanvas = L.canvasOverlay()
            .params({"stateShapes": [wrBorderGeo.features], "sources": sources})
            .drawing(drawingOnCanvas)
            .addTo(leafletMap);

    var mainCanvas = L.canvasOverlay()
            .params({stateShapes: [wrBorderGeo.features]})
            .drawing()
            .addTo(leafletMap);

    //draw markers for sources
    var markers = [];
    var myIcon = L.divIcon({
        iconSize: new L.Point(8, 8),
        html: ''
    });
    for (var i = 0; i < sources.length; i++) {
        markers.push(L.marker([sources[i][0], sources[i][1]], {icon: myIcon}).bindPopup(sources[i][5]));
    }
    var sourceMarkersLayer = L.layerGroup(markers);
    sourceMarkersLayer.addTo(leafletMap);
    borderCanvas.redraw();


    function drawingOnCanvas(canvasOverlay, params) {
        var ctx = params.canvas.getContext('2d');
        ctx.clearRect(0, 0, params.canvas.width, params.canvas.height);
        ctx.fillStyle = "rgba(255,255,255, 0.3)";
        for (var p = 0; p < params.options.stateShapes.length; p++) {
            for (var i = 0; i < params.options.stateShapes[p].length; i++) {
                if (params.options.stateShapes[p][i].geometry.type == "Polygon") {
                    var pathPoints = params.options.stateShapes[p][i].geometry.coordinates[0];
                    ctx.beginPath();
                    var pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[0][1], pathPoints[0][0]]);
                    ctx.moveTo(pt.x, pt.y);
                    for (var k = 1; k < pathPoints.length; k++) {
                        pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[k][1], pathPoints[k][0]]);
                        ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                } else if (params.options.stateShapes[p][i].geometry.type == "MultiPolygon") {
                    var polygonSet = params.options.stateShapes[p][i].geometry.coordinates;
                    for (var l = 1; l < polygonSet.length; l++) {
                        var pathPoints = polygonSet[l][0];
                        ctx.beginPath();
                        var pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[0][1], pathPoints[0][0]]);
                        ctx.moveTo(pt.x, pt.y);
                        for (var k = 1; k < pathPoints.length; k++) {
                            pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[k][1], pathPoints[k][0]]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
            //visualizeOnCanvas(canvasOverlay, params);
            //drawVoltageCircles(canvasOverlay, params);
            drawVoltageContour(canvasOverlay, params);
        }
    }

    function visualizeOnCanvas(canvasOverlay, params) {
        if (!mainCanvas) {
            return;
        }
        var ctx = mainCanvas.canvas().getContext('2d');
        ctx.clearRect(0, 0, mainCanvas.canvas().width, mainCanvas.canvas().height);
        ctx.fillStyle = "rgba(255,116,116, 0.5)";
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        //saving memory
        params.canvas = null;

        for (var x = 0; x < width / 2; x++) {
            for (var y = 0; y < height; y++) {
                var index = 4 * (x + y * width);
                if (imageData[index] > 0) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }

        }
    }

    function drawVoltageCircles(canvasOverlay, params) {
        var ctx = params.canvas.getContext('2d');
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        for (var k = 0; k < sources.length; k++) {
            var intensity = sources[k][2];
            if (intensity > 1.05) {
                intensity = 1.05;
            } else if (intensity < 0.95) {
                intensity = 0.95;
            }
            if (intensity >= 1) {
                ctx.fillStyle = "rgba(" + Math.floor(((intensity - 1) * 255) / 0.05) + ",0,0, 0.5)";
            } else {
                ctx.fillStyle = "rgba(0,0," + Math.floor(((1 - intensity) * 255) / 0.05) + ", 0.5)";
            }
            //get the pixel location and draw a circle
            var pt = canvasOverlay._map.latLngToContainerPoint([sources[k][0], sources[k][1]]);
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 0.5 * Math.pow(2, params.zoom), 0, 2 * Math.PI);
            ctx.fill();
        }
        //now apply filter via the filter array
        ctx.fillStyle = "rgba(255,255,255, 0.1)";
        var logicData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height);
        for (var index = 0; index < imageData.length; index++) {
            if (imageData[index] <= 0) {
                logicData.data[index + 3] = 0;
            }
        }
        //saving memory
        imageData = null;

        ctx.putImageData(logicData, 0, 0);
    }

    function drawVoltageContour(canvasOverlay, params) {
        var alpha = 0.5;
        var transparency = 0.3;
        var hotPU = 1.05;
        var coolPU = 0.95;
        var ctx = params.canvas.getContext('2d');
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        //for each pixel on the canvas filter...
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var index = 4 * (x + y * width);
                if (imageData[index] > 0) {
                    var canvasLatLng = canvasOverlay._map.containerPointToLatLng([x, y]);
                    //calculate the error contribution from each source and store in an array
                    var errorContributions = [];
                    for (var k = 0; k < sources.length; k++) {
                        var sourcePU = sources[k][2];
                        var sourcePUError = sourcePU - 1;
                        var sourcePtLat = sources[k][0];
                        var sourcePtLng = sources[k][1];
                        /*
                         calculate error contribution from this source
                         error(x,y)= SourcePUError * e^(- damping factor * distance of the source from (x,y) position)
                         error(x,y) = SourcePUError * e^((-Î±)*sqrt(x^2+y^2));
                         */
                        errorContributions[k] = sourcePUError * Math.exp(-alpha * Math.sqrt(Math.pow(sourcePtLat - canvasLatLng.lat, 2) + Math.pow(sourcePtLng - canvasLatLng.lng, 2)));
                    }
                    //calculate the resultant error from all contributions by considering the contribution that has the highest absolute value
                    var resultantError = errorContributions[0];
                    for (var p = 0; p < errorContributions.length; p++) {
                        if (Math.abs(errorContributions[p]) > Math.abs(resultantError)) {
                            resultantError = errorContributions[p];
                        }
                    }
                    if (resultantError + 1 > hotPU) {
                        resultantError = hotPU - 1;
                    } else if (resultantError + 1 < coolPU) {
                        resultantError = coolPU - 1;
                    }
                    //Now paint according to this error value
                    var resultantHue = 240 * ((1 + resultantError - coolPU) / (hotPU - coolPU));
                    var resultColor = hsvToRgb(240 - resultantHue, 1, 1);
                    ctx.fillStyle = "rgba(" + resultColor[0] + "," + resultColor[1] + "," + resultColor[2] + ", " + transparency + ")";
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
    }
</script>
</body>
</html>

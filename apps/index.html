<!doctype html>
<html>
<head>
    <title>Maharashtra Voltage Contour</title>
    <meta charset="utf-8">
    <link rel="shortcut icon" type="image/ico"
          href="https://raw.githubusercontent.com/POSOCO/LeafletCanvas/gh-pages/assets/favicon.ico"/>
    <link rel="stylesheet" type="text/css" href="../libs/css/font-awesome.min.css">
    <style>
        html, body {
            height: 100%;
        }

        #map {
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: #333;
        }

        .map-container {
            position: relative;
            display: inline-block;
            margin-left: 1%;
            margin-right: 10px;
            width: 50%;
            height: 80%;
            vertical-align: top;
        }

        .pagination > li {
            display: inline;
            margin-right: 10px;
        }

        table {
            border-collapse: collapse;
        }

        table, td, th {
            border: 1px solid black;
        }

        td {
            padding-left: 2px;
            padding-right: 2px;
        }

        #over_map_date {
            position: absolute;
            display: inline-block;
            bottom: 50px;
            /*
            width: 200px;
            height: 100px;
            */
            padding-right: 2px;
            padding-left: 2px;
            z-index: 90;
            pointer-events: none;
        }

        #over_map {
            position: absolute;
            bottom: 10px;
            right: 5px;
            opacity: 0.5;
            background-color: #dddddd;
            /*
            width: 200px;
            height: 100px;
            */
            padding-right: 5px;
            padding-left: 5px;
            z-index: 1;
            pointer-events: none;
            /*color: red;*/
        }

        #videoCanvas {
            left: 0;
            top: 0;
            position: absolute;
            height: 100%;
            width: 100%;
            background-color: transparent;
            pointer-events: none;
        }
    </style>
</head>
<body>
<h1>Maharashtra Voltage Contour</h1>

<div class="map-container">
    <div id="map"></div>
    <canvas id="videoCanvas"></canvas>
    <div style="position: absolute;display: inline-block;font-style: italic;color: #aaaaaa;z-index: 1000;width: 50%;height: 30px;bottom: 0px;">
        <span>Refresh time - </span><span id="refresh-time">NA</span><span> milli secs</span>
    </div>
    <p id="over_map" style="font-size: 30px;color: red">00:00 Hrs</p>

    <span id="over_map_date" style="font-style: italic;color: #aaaaaa">Voltage contour on xx-xx-xxxx</span>
</div>

<div class="container" ng-app="voltageSortApp" ng-controller="voltageSortController" id="voltage-report"
     style="display: inline-block;width: 45%;vertical-align:top;">
    <form>
        <div class="form-group">
            <div class="input-group">
                <input type="text" class="form-control" placeholder="Search Substation by name"
                       ng-model="searchLine">
                <label style="margin-left: 25px">Lines per Page</label>
                <input type="number" min="1" max="1000" class="form-control" ng-model="pageSize">
            </div>
        </div>
    </form>
    <br>
    <table>
        <thead>
        <tr>
            <td>
                <a class="sort-clicker" href="#" ng-click="sortType = 'sNo'; sortReverse = !sortReverse">
                    SNo
                    <span ng-show="sortType == 'sNo' && !sortReverse" class="fa fa-caret-down"></span>
                    <span ng-show="sortType == 'sNo' && sortReverse" class="fa fa-caret-up"></span>
                </a>
            </td>
            <td>
                <a class="sort-clicker" href="#" ng-click="sortType = 'name'; sortReverse = !sortReverse">
                    Substation
                    <span ng-show="sortType == 'name' && !sortReverse" class="fa fa-caret-down"></span>
                    <span ng-show="sortType == 'name' && sortReverse" class="fa fa-caret-up"></span>
                </a>
            </td>
            <td>
                <a class="sort-clicker" href="#"
                   ng-click="sortType = 'voltage'; sortReverse = !sortReverse">
                    Voltage
                    <span ng-show="sortType == 'voltage' && !sortReverse" class="fa fa-caret-down"></span>
                    <span ng-show="sortType == 'voltage' && sortReverse" class="fa fa-caret-up"></span>
                </a>
            </td>
            <td>
                <a class="sort-clicker" href="#"
                   ng-click="sortType = 'puVoltage'; sortReverse = !sortReverse">
                    PU
                    <span ng-show="sortType == 'puVoltage' && !sortReverse" class="fa fa-caret-down"></span>
                    <span ng-show="sortType == 'puVoltage' && sortReverse" class="fa fa-caret-up"></span>
                </a>
            </td>
        </tr>
        </thead>

        <tbody>
        <tr dir-paginate="source in sources | orderBy:sortType:sortReverse | filter:searchLine | itemsPerPage:pageSize">
            <td>{{ source.sNo }}</td>
            <td style="font-size: 0.95em">{{ source.name }}</td>
            <td>{{ source.voltage }}</td>
            <td>{{ source.puVoltage }}</td>
        </tr>
        </tbody>

    </table>
    <dir-pagination-controls
            max-size="5"
            direction-links="true"
            boundary-links="true">
    </dir-pagination-controls>
</div>

<br>

<div>
    <input type="range" id="videoTimeSlider" min="0" max="0" value="0" step="1" style="margin-left:1%;width:50%"
           onchange="updateVideoTime()">
    <span id="videoTimeString"></span>
    <button id="drawSnapshotButton" onclick="paintCachedFrame()">Refresh</button>
    <label><input type="checkbox" id="autoRefresh" checked>AutoRefresh</label>
</div>
<div id="controlInputs" style="margin:10px 5px 5px 10px;"><!--top right bottom left-->
    <button onclick="startFetching()">StartFetching</button>
    <button onclick="pauseFetching()">StopFetching</button>
    <span style="padding-left:15px;"></span>
    <button onclick="startFrameFetching()">CSVPlay</button>
    <button onclick="pauseFrameFetching()">CSVPause</button>
    <span id="playbackStatus"></span>
    <span id="playbackStatusPaused"></span>
    <span style="padding-left:20px;"></span>
    <input id="jumpToFrameInput" type="number" value="0" style="width:45px;"/>
    <button onclick="jumpToFrameGUI()"> JumpToMinute</button>
    <span style="padding-left:20px;"></span>
    <input id="frameRateInput" type="number" value="5" style="width:35px;"/>
    <button onclick="setFrameRateGUI()"> SetMinuteRate</button>
    <br><br>
    <button onclick="startFramePlaying()">PlayCachedData</button>
    <button onclick="pauseFramePlaying()">PauseCachedData</button>
    <input id="cachePlayIntervalInput" type="number" min="30" max="1000" value="200" placeholder="cacheInterval">
    <button id="setCacheIntervalButton" onclick="setCachePlayInterval()">SetCachePlayBackInterval</button>
    <br>
    <span>Select the voltage files</span>
    <input type="file" id="fileInput">
    <br><br>
    <input id="alphaTextControl" style="width:50px;" type="number" value="2"/>
    <button onclick="setAlpha()">Set Alpha</button>
    <input id="TransTextControl" style="width:50px;margin-left:25px" type="number" value="0.4"/>
    <button onclick="setTransparency()">Set Transparency</button>
    <br><br>
</div>
<link rel="stylesheet" href="../libs/leaflet.css"/>
<link rel="stylesheet" type="text/css" href="../libs/leaflet-openweathermap.css"/>
<style>
    .leaflet-div-icon {
        border-radius: 50%;
        behavior: url(PIE.htc); /* remove if you don't care about IE8 */
        background: rgba(0, 0, 0, 0);
        border: 1px solid #aaa;
    }
</style>
<script src="../libs/leaflet.js"></script>
<script src="../libs/L.CanvasOverlay.js"></script>
<script type="text/javascript" src="../libs/leaflet-openweathermap.js"></script>
<script src="../border-geos/maharashtra-geo.js" charset="utf-8"></script>
<script src="../libs/angular.min.js"></script>
<script src="../libs/dirPagination.js"></script>
<script src="../sources-table.js" charset="utf-8"></script>
<script src="../sources.js" charset="utf-8"></script>
<script src="../libs/rgbhsv.js" charset="utf-8"></script>

<script src="../libs/jquery.min.js" charset="utf-8"></script>
<script src="../timeFrames.js" charset="utf-8"></script>
<script src="../libs/csvToArray.js" charset="utf-8"></script>
<script src="../CSVReader.js" charset="utf-8"></script>
<script src="../playCached.js" charset="utf-8"></script>
<script src="../playFromCSV.js" charset="utf-8"></script>
<script src="../index-csv.js" charset="utf-8"></script>
<script>
    // All the geoJSONs are copied from http://www.partners-popdev.org/wp-content/themes/original-child/vendor/Geojson/

    //var sources = [[21.6, 71.21, 1.05, "WRLDCMP.SCADA1.A0048293", 400, "AMRELI 400kV SUBSTATION, Gujrat, SUBSTN.AMRL_JTG.BUS.4B1.MES1.KVRY", "OK"]];
    var specificSourcesIndices = [42, 163, 50, 38, 133, 69, 35, 46, 53, 157, 156, 77, 79, 2, 132, 127, 18, 8, 44, 49, 80, 56, 36, 55, 31];

    window.setTimeout(function () {
        angular.element(document.getElementById('voltage-report')).scope().updateSources(sources);
    }, 500);

    var osmTileLayer = L.tileLayer("http://{s}.tile.osm.org/{z}/{x}/{y}.png", {id: 'map'});
    var mapStackTileLayer = L.tileLayer("http://{s}.sm.mapstack.stamen.com/(toner-lite,$fff[difference],$fff[@23],$fff[hsl-saturation@20])/{z}/{x}/{y}.png", {id: 'map'});

    var leafletMap = L.map('map').setView([18.87510275035649, 76.5252685546875], 7);
    mapStackTileLayer.addTo(leafletMap);
    //create geoJSON border by svg
    //L.geoJson(statesData).addTo(leafletMap);
    var borderCanvasLayer = L.canvasOverlay()
            .params({"stateShapes": [msebBorderGeo.features]})
            .drawing(drawingOnCanvas)
            .addTo(leafletMap);
    videoCanvas_.width = borderCanvasLayer.canvas().width;
    videoCanvas_.height = borderCanvasLayer.canvas().height;
    //videoCanvasCtx_ = videoCanvas_.getContext("2d");
    videoCanvasCtx_ = borderCanvasLayer.canvas().getContext("2d");
    //draw markers for sources
    var markers = [];
    var myIcon = L.divIcon({
        iconSize: new L.Point(8, 8),
        html: ''
    });
    for (var i = 0; i < sources.length; i++) {
        markers.push(L.marker([sources[i][0], sources[i][1]], {icon: myIcon}).bindPopup(sources[i][5]));
    }
    var sourceMarkersLayer = L.layerGroup(markers);
    sourceMarkersLayer.addTo(leafletMap);
    var hotPU_ = 1.05;
    var coolPU_ = 0.95;
    var alpha_ = 2;
    var transparency_ = 0.4;
    //Getting OpenWeatherMapOverlays
    var clouds = L.OWM.clouds({showLegend: false, opacity: 0.5});
    var cloudsClassic = L.OWM.cloudsClassic();
    var precipitation = L.OWM.precipitation();
    var precipitationClassic = L.OWM.precipitationClassic();
    var rain = L.OWM.rain();
    var rainClassic = L.OWM.rainClassic();
    var snow = L.OWM.snow();
    var pressure = L.OWM.pressure();
    var pressureContour = L.OWM.pressureContour();
    var temperature = L.OWM.temperature();
    var wind = L.OWM.wind();

    //Creating base maps and overlay maps controls
    var baseMaps = {
        "OpenStreetMaps": osmTileLayer,
        "MapStack": mapStackTileLayer
    };
    var overlayMaps = {
        "Voltage Contour": borderCanvasLayer,
        "Substations": sourceMarkersLayer,
        "Clouds": clouds,
        "Clouds Classic": cloudsClassic,
        "Precipitation": precipitation,
        "Precipitation Classic": precipitationClassic,
        "Rain": rain,
        "Rain Classic": rainClassic,
        "Snow": snow,
        "Pressure": pressure,
        "Pressure Contour": pressureContour,
        "Temperature": temperature,
        "Wind": wind
    };
    L.control.layers(baseMaps, overlayMaps).addTo(leafletMap);

    borderCanvasLayer.redraw();

    function drawingOnCanvas(canvasOverlay, params) {
        var ctx = params.canvas.getContext('2d');
        ctx.clearRect(0, 0, params.canvas.width, params.canvas.height);
        ctx.fillStyle = "rgba(255,255,255, 0.3)";
        ctx.strokeStyle = "rgba(255,116,0, 0.1)";
        for (var p = 0; p < params.options.stateShapes.length; p++) {
            for (var i = 0; i < params.options.stateShapes[p].length; i++) {
                if (params.options.stateShapes[p][i].geometry.type == "Polygon") {
                    var pathPoints = params.options.stateShapes[p][i].geometry.coordinates[0];
                    ctx.beginPath();
                    var pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[0][1], pathPoints[0][0]]);
                    ctx.moveTo(pt.x, pt.y);
                    for (var k = 1; k < pathPoints.length; k++) {
                        pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[k][1], pathPoints[k][0]]);
                        ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                } else if (params.options.stateShapes[p][i].geometry.type == "MultiPolygon") {
                    var polygonSet = params.options.stateShapes[p][i].geometry.coordinates;
                    for (var l = 1; l < polygonSet.length; l++) {
                        var pathPoints = polygonSet[l][0];
                        ctx.beginPath();
                        var pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[0][1], pathPoints[0][0]]);
                        ctx.moveTo(pt.x, pt.y);
                        for (var k = 1; k < pathPoints.length; k++) {
                            pt = canvasOverlay._map.latLngToContainerPoint([pathPoints[k][1], pathPoints[k][0]]);
                            ctx.lineTo(pt.x, pt.y);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }
            //visualizeOnCanvas(canvasOverlay, params);
            //drawVoltageCircles(canvasOverlay, params);
            //drawVoltageContour(canvasOverlay, params);
            drawApproxVoltageContour(canvasOverlay, params);
            //drawFastVoltageContour(canvasOverlay, params);
            //drawNewFastVoltageContour(canvasOverlay, params);
        }
    }

    function visualizeOnCanvas(canvasOverlay, params) {
        var ctx = params.canvas.getContext('2d');
        ctx.fillStyle = "rgba(255,116,116, 0.5)";
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        ctx.clearRect(0, 0, params.canvas.width, params.canvas.height);
        var width = params.canvas.width;
        var height = params.canvas.height;
        //saving memory
        params.canvas = null;
        for (var x = 0; x < width / 2; x++) {
            for (var y = 0; y < height; y++) {
                var index = 4 * (x + y * width);
                if (imageData[index] > 0) {
                    ctx.fillRect(x, y, 1, 1);
                }
            }

        }
    }

    function drawVoltageCircles(canvasOverlay, params) {
        var ctx = params.canvas.getContext('2d');
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        for (var k = 0; k < sources.length; k++) {
            var intensity = sources[k][2];
            if (intensity > 1.05) {
                intensity = 1.05;
            } else if (intensity < 0.95) {
                intensity = 0.95;
            }
            if (intensity >= 1) {
                ctx.fillStyle = "rgba(" + Math.floor(((intensity - 1) * 255) / 0.05) + ",0,0, 0.5)";
            } else {
                ctx.fillStyle = "rgba(0,0," + Math.floor(((1 - intensity) * 255) / 0.05) + ", 0.5)";
            }
            //get the pixel location and draw a circle
            var pt = canvasOverlay._map.latLngToContainerPoint([sources[k][0], sources[k][1]]);
            ctx.beginPath();
            ctx.arc(pt.x, pt.y, 0.5 * Math.pow(2, params.zoom), 0, 2 * Math.PI);
            ctx.fill();
        }
        //now apply filter via the filter array
        ctx.fillStyle = "rgba(255,255,255, 0.1)";
        var logicData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height);
        for (var index = 0; index < imageData.length; index++) {
            if (imageData[index] <= 0) {
                logicData.data[index + 3] = 0;
            }
        }
        //saving memory
        imageData = null;

        ctx.putImageData(logicData, 0, 0);
    }

    function drawVoltageContour(canvasOverlay, params) {
        var timeStart = new Date();
        var alpha = 1.5;
        var transparency = 0.3;
        var hotPU = 1.05;
        var coolPU = 0.95;
        var ctx = params.canvas.getContext('2d');
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        //for each pixel on the canvas filter...
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var index = 4 * (x + y * width);
                if (imageData[index] > 0) {
                    var canvasLatLng = canvasOverlay._map.containerPointToLatLng([x, y]);
                    //calculate the error contribution from each source and store in an array
                    var errorContributions = [];
                    for (var k = 0; k < sources.length; k++) {
                        var sourcePU = sources[k][2];
                        var sourcePUError = sourcePU - 1;
                        var sourcePtLat = sources[k][0];
                        var sourcePtLng = sources[k][1];
                        /*
                         calculate error contribution from this source
                         error(x,y)= SourcePUError * e^(- damping factor * distance of the source from (x,y) position)
                         error(x,y) = SourcePUError * e^((-α)*sqrt(x^2+y^2));
                         */
                        errorContributions[k] = sourcePUError * Math.exp(-alpha * Math.sqrt(Math.pow(sourcePtLat - canvasLatLng.lat, 2) + Math.pow(sourcePtLng - canvasLatLng.lng, 2)));
                    }
                    //calculate the resultant error from all contributions by considering the contribution that has the highest absolute value
                    var resultantError = errorContributions[0];
                    for (var p = 0; p < errorContributions.length; p++) {
                        if (Math.abs(errorContributions[p]) > Math.abs(resultantError)) {
                            resultantError = errorContributions[p];
                        }
                    }
                    if (resultantError + 1 > hotPU) {
                        resultantError = hotPU - 1;
                    } else if (resultantError + 1 < coolPU) {
                        resultantError = coolPU - 1;
                    }
                    //Now paint according to this error value
                    var resultantHue = 240 * ((1 + resultantError - coolPU) / (hotPU - coolPU));
                    var resultColor = hsvToRgb(240 - resultantHue, 1, 1);
                    ctx.fillStyle = "rgba(" + resultColor[0] + "," + resultColor[1] + "," + resultColor[2] + ", " + transparency + ")";
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        document.getElementById("refresh-time").innerHTML = (new Date() - timeStart);
    }

    function drawApproxVoltageContour(canvasOverlay, params) {
        var timeStart = new Date();
        var hotPU = hotPU_;
        var coolPU = coolPU_;
        var ctx = params.canvas.getContext('2d');
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        var width = params.canvas.width;
        var height = params.canvas.height;
        var alpha = alpha_;
        var transparency = transparency_;
        //npx = latSpan/canvasWidth; npy = lngSpan/canvasHeight; npxRatioSquare = npy*npy/(npx*npx);
        var southEast = leafletMap.getBounds().getSouthEast();
        var northWest = leafletMap.getBounds().getNorthWest();
        var npx = (southEast.lng - northWest.lng) / width;
        npx = Math.abs(npx);
        var npy = (northWest.lat - southEast.lat) / height;
        npy = Math.abs(npy);
        var npxRatioSquare = (npy * npy) / (npx * npx);

        //calculate source pixel locations
        var sourcePixelLocations = [];
        for (var i = 0; i < sources.length; i++) {
            if (sources[i][6] != "OK") {
                sources[i][2] = 1;
            }
            sourcePixelLocations.push(canvasOverlay._map.latLngToContainerPoint([sources[i][0], sources[i][1]]));
        }
        var sourcePU;
        var sourcePUError;
        var sourcePtLat;
        var sourcePtLng;
        var errorContributions;
        //for each pixel on the canvas filter...
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var index = 4 * (x + y * width);
                if (imageData[index] > 0) {
                    //calculate the error contribution from each source and store in an array
                    errorContributions = [];
                    for (var k = 0; k < sources.length; k++) {
                        if (specificSourcesIndices.indexOf(k) != -1) {
                            sourcePU = sources[k][2];
                            sourcePUError = sourcePU - 1;
                            sourcePtLat = sources[k][0];
                            sourcePtLng = sources[k][1];
                            /*
                             calculate error contribution from this source
                             error(x,y)= SourcePUError * e^(- damping factor * distance of the source from (x,y) position)
                             error(x,y) = SourcePUError * e^((-α)*sqrt(x^2+y^2));
                             */
                            errorContributions[k] = sourcePUError * Math.exp(-alpha * npx * Math.sqrt(Math.pow(sourcePixelLocations[k].x - x, 2) + Math.pow(sourcePixelLocations[k].y - y, 2)));
                        } else {
                            errorContributions[k] = 0;
                        }
                    }
                    //calculate the resultant error from all contributions by considering the contribution that has the highest absolute value
                    var resultantError = errorContributions[0];
                    for (var p = 0; p < errorContributions.length; p++) {
                        if (Math.abs(errorContributions[p]) > Math.abs(resultantError)) {
                            resultantError = errorContributions[p];
                        }
                    }
                    if (resultantError + 1 > hotPU) {
                        resultantError = hotPU - 1;
                    } else if (resultantError + 1 < coolPU) {
                        resultantError = coolPU - 1;
                    }
                    //Now paint according to this error value
                    var resultantHue = 240 * ((1 + resultantError - coolPU) / (hotPU - coolPU));
                    var resultColor = hsvToRgb(240 - resultantHue, 1, 1);
                    ctx.fillStyle = "rgba(" + resultColor[0] + "," + resultColor[1] + "," + resultColor[2] + ", " + transparency + ")";
                    ctx.fillRect(x, y, 1, 1);
                }
            }
        }
        document.getElementById("refresh-time").innerHTML = (new Date() - timeStart);
    }

    function drawFastVoltageContour(canvasOverlay, params) {
        var sources = [[21.6, 71.21, 1.05, "WRLDCMP.SCADA1.A0048293", 400, "AMRELI 400kV SUBSTATION, Gujrat, SUBSTN.AMRL_JTG.BUS.4B1.MES1.KVRY", "OK"]];
        //var source = [sources[0], sources[1]];
        var alpha = 0.8;
        var transparency = 0.3;
        var hotPU = 1.05;
        var coolPU = 0.95;
        var ctx = params.canvas.getContext('2d');
        var width = params.canvas.width;
        var height = params.canvas.height;
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        ctx.clearRect(0, 0, width, height);
        var contourData = [];
        for (var iter = 0; iter < width * height; iter++) {
            contourData[iter] = 1;
        }
        //npx = latSpan/canvasWidth; npy = lngSpan/canvasHeight; npxRatioSquare = npy*npy/(npx*npx);
        var southEast = leafletMap.getBounds().getSouthEast();
        var northWest = leafletMap.getBounds().getNorthWest();
        var npx = (southEast.lng - northWest.lng) / width;
        npx = Math.abs(npx);
        var npy = (northWest.lat - southEast.lat) / height;
        npy = Math.abs(npy);
        var npxRatioSquare = (npy * npy) / (npx * npx);
        for (var i = 0; i < sources.length; i++) {
            //skip from the for loop if sources status is not "OK"
            if (sources[i][6] != "OK" || sources[i][2] < 0.8) {
                continue;
            }
            var vsource = sources[i][2];
            var vsourceError = vsource - 1;
            //calculate the source pixel point
            var sourcePt = canvasOverlay._map.latLngToContainerPoint([sources[i][0], sources[i][1]]);
            var xpsource = sourcePt.x;
            var ypsource = sourcePt.y;
            var stopYIteration = false;
            //x should go from sourcex to sourcex+width-sourcex
            for (var xpdest = xpsource; xpdest <= width; xpdest++) {
                stopYIteration = false;
                for (var ypdest = ypsource; stopYIteration == false; ypdest++) {
                    var xpx = xpdest - xpsource;
                    var ypx = ypdest - ypsource;
                    if ((ypx > xpx) || (ypdest > height)) {
                        stopYIteration = true;
                        continue;
                    }
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    var xCoordinates = [xpdest, xpsource - xpx, xpdest, xpsource - xpx, xpsource + ypx, xpsource - ypx, xpsource + ypx, xpsource - ypx];
                    var yCoordinates = [ypdest, ypdest, ypsource - ypx, ypsource - ypx, ypsource + xpx, ypsource + xpx, ypsource - xpx, ypsource - xpx];
                    var isValToAddCalculated = false;
                    var valToAdd = 0;
                    //First find if value needs to be calculated by checking if filter exists in any of the 8 quadrants
                    for (var coordIter = 0; coordIter < 8; coordIter++) {
                        var xCoord = xCoordinates[coordIter];
                        var yCoord = yCoordinates[coordIter];
                        if (ypx == 0 && (coordIter == 1 || coordIter == 2 || coordIter == 5 || coordIter == 7)) {
                            continue;
                        } else if (ypx == xpx && coordIter < 4) {
                            continue;
                        }
                        if (imageData[(yCoord * width + xCoord) * 4] == 255 && xCoord >= 0 && yCoord >= 0 && xCoord <= width && yCoord <= height) {
                            if (!isValToAddCalculated) {
                                valToAdd = vsourceError * Math.exp(-alpha * npx * Math.sqrt(xpx * xpx + npxRatioSquare * ypx * ypx));
                                valToAdd += 1;
                                isValToAddCalculated = true;
                            }
                            /**implementing overriding contour**/
                            var canvasPixelPU = contourData[(xCoord + yCoord * width)];
                            if (Math.abs(valToAdd - 1) > Math.abs(canvasPixelPU - 1)) {
                                canvasPixelPU = valToAdd;
                            }
                            contourData[(xCoord + yCoord * width)] = canvasPixelPU;
                        } else {
                            contourData[(xCoord + yCoord * width)] = null;
                        }
                    }
                }
            }
        }
        //now all pixel values found; bug in for loop iteration limits of xpdest

        //saving memory;
        imageData = null;

        //paint the pixels
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var index = x + y * width;
                var resultantPU = contourData[index];
                if (resultantPU == null) {
                    continue;
                }
                if (resultantPU > hotPU) {
                    resultantPU = hotPU;
                } else if (resultantPU < coolPU) {
                    resultantPU = coolPU;
                }
                //Now paint according to this error value
                var resultantHue = 240 * ((resultantPU - coolPU) / (hotPU - coolPU));
                var resultColor = hsvToRgb(240 - resultantHue, 1, 1);
                ctx.fillStyle = "rgba(" + resultColor[0] + "," + resultColor[1] + "," + resultColor[2] + ", " + transparency + ")";
                ctx.fillRect(x, y, 1, 1);
            }
        }
    }

    function drawNewFastVoltageContour(canvasOverlay, params) {
        var timeStart = new Date;
        //var sources = [[21.6, 71.21, 1.15, "WRLDCMP.SCADA1.A0048293", 400, "AMRELI 400kV SUBSTATION, Gujrat, SUBSTN.AMRL_JTG.BUS.4B1.MES1.KVRY", "OK"]];
        //var source = [sources[0], sources[1]];
        var alpha = 0.8;
        var transparency = 0.3;
        var hotPU = 1.05;
        var coolPU = 0.95;
        var ctx = params.canvas.getContext('2d');
        var width = params.canvas.width;
        var height = params.canvas.height;
        var imageData = params.canvas.getContext('2d').getImageData(0, 0, params.canvas.width, params.canvas.height).data;
        ctx.clearRect(0, 0, width, height);
        var contourData = [];
        for (var iter = 0; iter < width * height; iter++) {
            contourData[iter] = 1;
        }
        //npx = latSpan/canvasWidth; npy = lngSpan/canvasHeight; npxRatioSquare = npy*npy/(npx*npx);
        var southEast = leafletMap.getBounds().getSouthEast();
        var northWest = leafletMap.getBounds().getNorthWest();
        var npx = (southEast.lng - northWest.lng) / width;
        npx = Math.abs(npx);
        var npy = (northWest.lat - southEast.lat) / height;
        npy = Math.abs(npy);
        var npxRatioSquare = (npy * npy) / (npx * npx);
        for (var i = 0; i < sources.length; i++) {
            //skip from the for loop if sources status is not "OK"
            if (sources[i][6] != "OK" || sources[i][2] < 0.8) {
                continue;
            }
            var vsource = sources[i][2];
            var vsourceError = vsource - 1;
            //find the distance till the error propagation needs to be considered
            if (sources[i][4] * vsourceError >= 1) {
                var distDegrees = Math.log(sources[i][4] * vsourceError) / alpha;
            } else {
                var distDegrees = 0;
            }

            //calculate the source pixel point
            var sourcePt = canvasOverlay._map.latLngToContainerPoint([sources[i][0], sources[i][1]]);
            var xpsource = sourcePt.x;
            var ypsource = sourcePt.y;
            //calculate the source boundary of influence
            var xpDestStartDegrees = sources[i][0] - distDegrees;
            var xpDestEndDegrees = sources[i][0] + distDegrees;
            var ypDestStartDegrees = sources[i][1] - distDegrees;
            var ypDestEndDegrees = sources[i][1] + distDegrees;
            xpDestStartDegrees = correctDegrees(xpDestStartDegrees);
            xpDestEndDegrees = correctDegrees(xpDestEndDegrees);
            ypDestStartDegrees = correctDegrees(ypDestStartDegrees);
            ypDestEndDegrees = correctDegrees(ypDestEndDegrees);
            var sourceStartPixelPoint = canvasOverlay._map.latLngToContainerPoint([xpDestStartDegrees, ypDestStartDegrees]);
            var sourceEndPixelPoint = canvasOverlay._map.latLngToContainerPoint([xpDestEndDegrees, ypDestEndDegrees]);
            for (var xpdest = Math.min(sourceStartPixelPoint.x, sourceEndPixelPoint.x); xpdest <= Math.max(sourceStartPixelPoint.x, sourceEndPixelPoint.x); xpdest++) {
                var stopYIteration = false;
                for (var ypdest = Math.min(sourceStartPixelPoint.y, sourceEndPixelPoint.y); (ypdest <= Math.max(sourceStartPixelPoint.y, sourceEndPixelPoint.y)) || (stopYIteration == false); ypdest++) {
                    var xpx = xpdest - xpsource;
                    var ypx = ypdest - ypsource;
                    if (ypx > xpx) {
                        stopYIteration = true;
                        continue;
                    }
                    //i = source iterator; xpdest = x axis iterator; ypdest = y axis iterator
                    var xCoordinates = [xpdest, xpsource - xpx, xpdest, xpsource - xpx, xpsource + ypx, xpsource - ypx, xpsource + ypx, xpsource - ypx];
                    var yCoordinates = [ypdest, ypdest, ypsource - ypx, ypsource - ypx, ypsource + xpx, ypsource + xpx, ypsource - xpx, ypsource - xpx];
                    var isValToAddCalculated = false;
                    var valToAdd = 0;
                    //First find if value needs to be calculated by checking if filter exists in any of the 8 quadrants
                    for (var coordIter = 0; coordIter < 8; coordIter++) {
                        var xCoord = xCoordinates[coordIter];
                        var yCoord = yCoordinates[coordIter];
                        if (ypx == 0 && (coordIter == 1 || coordIter == 2 || coordIter == 5 || coordIter == 7)) {
                            continue;
                        } else if (ypx == xpx && coordIter < 4) {
                            continue;
                        }
                        if (imageData[(yCoord * width + xCoord) * 4] == 255 && xCoord >= 0 && yCoord >= 0 && xCoord <= width && yCoord <= height) {
                            if (!isValToAddCalculated) {
                                valToAdd = vsourceError * Math.exp(-alpha * npx * Math.sqrt(xpx * xpx + npxRatioSquare * ypx * ypx));
                                valToAdd += 1;
                                isValToAddCalculated = true;
                            }
                            /**implementing overriding contour**/
                            var canvasPixelPU = contourData[(xCoord + yCoord * width)];
                            if (Math.abs(valToAdd - 1) > Math.abs(canvasPixelPU - 1)) {
                                canvasPixelPU = valToAdd;
                            }
                            contourData[(xCoord + yCoord * width)] = canvasPixelPU;
                        }
                    }
                }
            }
        }
        //now all pixel values found;

        //mask the filtered area
        for (xCoord = 0; xCoord < width; xCoord++) {
            for (yCoord = 0; yCoord < height; yCoord++) {
                if (imageData[(yCoord * width + xCoord) * 4] != 255) {
                    contourData[(xCoord + yCoord * width)] = null;
                }
            }
        }
        //saving memory;
        imageData = null;

        //paint the pixels
        for (var x = 0; x < width; x++) {
            for (var y = 0; y < height; y++) {
                var index = x + y * width;
                var resultantPU = contourData[index];
                if (resultantPU == null) {
                    continue;
                }
                if (resultantPU > hotPU) {
                    resultantPU = hotPU;
                } else if (resultantPU < coolPU) {
                    resultantPU = coolPU;
                }
                //Now paint according to this error value
                var resultantHue = 240 * ((resultantPU - coolPU) / (hotPU - coolPU));
                var resultColor = hsvToRgb(240 - resultantHue, 1, 1);
                ctx.fillStyle = "rgba(" + resultColor[0] + "," + resultColor[1] + "," + resultColor[2] + ", " + transparency + ")";
                ctx.fillRect(x, y, 1, 1);
            }
        }
        document.getElementById("refresh-time").value = (new Date() - timeStart);
    }

    function correctDegrees(degrees) {
        if (degrees > 180 && degrees > 0) {
            return degrees - Math.floor(degrees / 180) * 180;
        } else if (degrees < 180 && degrees < 0) {
            return degrees - Math.ceil(degrees / 180) * 180;
        }
        return degrees;
    }

    function setAlpha() {
        var temp = document.getElementById("alphaTextControl").value;
        if (!isNaN(temp)) {
            alpha_ = +temp;
        }
    }

    function setTransparency() {
        var temp = document.getElementById("TransTextControl").value;
        if (!isNaN(temp)) {
            transparency_ = +temp;
        }
    }
</script>
</body>
</html>
